"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const steem_1 = __importDefault(require("steem"));
const MAX_PAYLOAD_SIZE = 2000;
const MAX_ACCOUNTS_CHECK = 999;
exports.Utils = {
    // https://flaviocopes.com/javascript-sleep/
    sleep(milliseconds) {
        return new Promise((resolve) => setTimeout(resolve, milliseconds));
    },
    jsonParse(str) {
        let obj;
        try {
            obj = JSON.parse(str);
        }
        catch (_a) {
            // We don't do anything
        }
        return obj;
    },
    transferSteemTokens(config, from, to, amount, symbol, memo = '') {
        return steem_1.default.broadcast.transferAsync(config.ACTIVE_KEY, from, to, `${parseFloat(amount).toFixed(3)} ${symbol}`, memo);
    },
    transferSteemEngineTokens(config, from, to, quantity, symbol, memo = '') {
        const json = {
            contractName: 'tokens',
            contractAction: 'transfer',
            contractPayload: {
                symbol: symbol.toUpperCase(),
                to,
                quantity,
                memo,
            },
        };
        return steem_1.default.broadcast.customJsonAsync(config.ACTIVE_KEY, [from], null, config.CHAIN_ID, JSON.stringify(json));
    },
    transferSteemEngineTokensMultiple(config, from, accounts, symbol, memo, amount = '0') {
        return __awaiter(this, void 0, void 0, function* () {
            const payloads = [[]];
            let completed = 0;
            for (const user of accounts) {
                const account = user.account.replace('@', '');
                const quantity = user.amount ? parseFloat(user.amount.replace(',', '.')) : parseFloat(amount);
                // 0 means no quantity supplied (either in accounts or default)
                if (quantity > 0) {
                    const json = {
                        contractName: 'tokens',
                        contractAction: 'transfer',
                        contractPayload: {
                            symbol: symbol.toUpperCase(),
                            to: account,
                            quantity,
                            memo,
                        },
                    };
                    const lastPayloadSize = JSON.stringify(payloads[payloads.length - 1]).length;
                    const payloadSize = JSON.stringify(json).length;
                    if (payloadSize + lastPayloadSize > MAX_PAYLOAD_SIZE) {
                        payloads.push([json]);
                    }
                    else {
                        payloads[payloads.length - 1].push(json);
                    }
                }
            }
            for (const payload of payloads) {
                const requiredAuths = [from];
                const requiredPostingAuths = null;
                yield steem_1.default.broadcast.customJsonAsync(config.ACTIVE_KEY, requiredAuths, requiredPostingAuths, config.CHAIN_ID, JSON.stringify(payload));
                completed++;
                if (completed !== (payloads.length) && completed !== 0) {
                    yield this.sleep(3000);
                }
            }
        });
    },
    issueSteemEngineTokens(config, from, to, symbol, quantity, memo = '') {
        const json = {
            contractName: 'tokens',
            contractAction: 'issue',
            contractPayload: {
                symbol,
                to,
                quantity,
                memo,
            },
        };
        if (config.DEBUG_MODE) {
            console.log(`Issuing Steem Engine Token: `, json, JSON.stringify(json));
        }
        return steem_1.default.broadcast.customJsonAsync(config.ACTIVE_KEY, [from], null, config.CHAIN_ID, JSON.stringify(json));
    },
    issueSteemEngineTokensMultiple(config, from, accounts, symbol, memo, amount = '0') {
        return __awaiter(this, void 0, void 0, function* () {
            const payloads = [[]];
            let completed = 0;
            for (const user of accounts) {
                const to = user.account.replace('@', '');
                const quantity = user.amount ? parseFloat(user.amount.replace(',', '.')) : parseFloat(amount);
                // 0 means no quantity supplied (either in accounts or default)
                if (quantity > 0) {
                    const json = {
                        contractName: 'tokens',
                        contractAction: 'issue',
                        contractPayload: {
                            symbol: symbol.toUpperCase(),
                            to,
                            quantity,
                            memo,
                        },
                    };
                    const lastPayloadSize = JSON.stringify(payloads[payloads.length - 1]).length;
                    const payloadSize = JSON.stringify(json).length;
                    if (payloadSize + lastPayloadSize > MAX_PAYLOAD_SIZE) {
                        payloads.push([json]);
                    }
                    else {
                        payloads[payloads.length - 1].push(json);
                    }
                }
            }
            for (const payload of payloads) {
                const requiredAuths = [from];
                const requiredPostingAuths = null;
                yield steem_1.default.broadcast.customJsonAsync(config.ACTIVE_KEY, requiredAuths, requiredPostingAuths, config.CHAIN_ID, JSON.stringify(payload));
                completed++;
                if (completed !== (payloads.length) && completed !== 0) {
                    yield this.sleep(3000);
                }
            }
        });
    },
    upvote(config, from, votePercentage = '100.0', username, permlink) {
        const percentage = parseFloat(votePercentage);
        if (percentage < 0) {
            throw new Error('Negative voting values are for downvotes, not upvotes');
        }
        const weight = this.votingWeight(percentage);
        return steem_1.default.broadcast.voteAsync(config.POSTING_KEY, from, username, permlink, weight);
    },
    downvote(config, from, votePercentage = '100.0', username, permlink) {
        const weight = this.votingWeight(parseFloat(votePercentage)) * -1;
        return steem_1.default.broadcast.voteAsync(config.POSTING_KEY, from, username, permlink, weight);
    },
    votingWeight(votePercentage) {
        return Math.min(Math.floor(parseFloat(votePercentage.toFixed(2)) * 100), 10000);
    },
};
//# sourceMappingURL=utils.js.map